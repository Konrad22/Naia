#textdomain wesnoth-Naia

# Used to negate {IS_HERO}.
#define NO_OVERLAYS_NO_ELLIPSE
    overlays=""
    ellipse="" # wmllint: no ellipsecheck
#enddef

#define NO_UPKEEP_NO_OVERLAY
    [+unit]
        # dammit, esr
        upkeep=loyal
    [/unit]
#enddef

#define PETRIFIED
    [+unit]
        [status]
            petrified=yes
        [/status]
    [/unit]
#enddef

#define GENDER _GENDER
    [+unit]
        gender={_GENDER}
    [/unit]
#enddef

#define PLACEMENT _PLACEMENT
    [+unit]
        placement={_PLACEMENT}
    [/unit]
#enddef

#define PALETTE _SRC _DEST
    [+unit]
        [+modifications]
            [object]
                [effect]
                    apply_to="image_mod"
                    add="PAL("+{_SRC}+">"+{_DEST}+")"
                [/effect]
            [/object]
        [/modifications]
    [/unit]
#enddef

#define DOOR_TILES_TO_UNITS _DOOR_OWNER_SIDE
    [setup_doors]
        side={_DOOR_OWNER_SIDE}
    [/setup_doors]
#enddef

#define FACE_DIRECTION _SUF _DIRECTION
    [set_facing]
        [filter]
            {_SUF}
        [/filter]
        facing={_DIRECTION}
    [/set_facing]
#enddef

#define FACE_LOCATION _SUF _TARGET_SLF
    [set_facing]
        [filter]
            {_SUF}
        [/filter]
        [filter_location]
            {_TARGET_SLF}
        [/filter_location]
    [/set_facing]
#enddef

#define FACE_UNIT _SUF _TARGET_SUF
    [set_facing]
        [filter]
            {_SUF}
        [/filter]
        [filter_second]
            {_TARGET_SUF}
        [/filter_second]
    [/set_facing]
#enddef

#define IS_VILLAGE_CONTROL_DUMMY
    canrecruit=yes
    type=Invisible Dummy
    name=" " # wmllint:ignore
#enddef

#define FAKE_RECRUIT _SIDE _TYPE _X _Y
    [unit]
        side={_SIDE}
        type={_TYPE}
        x={_X}
        y={_Y}
        random_gender=yes
        random_traits=yes
        generate_name=yes
        moves=0
        attacks_left=0
        animate=yes
    [/unit]
#enddef

#define UNIT_PALETTE_SWITCH _SUF _FROM _TO
    [object]
        silent=yes
        [filter]
            {_SUF}
        [/filter]
        [effect]
            apply_to=image_mod
            add="PAL("+{_FROM}+">"+{_TO}+")"
        [/effect]
    [/object]
#enddef

#define MOBILIZE_GUARDIANS _SUF
    [store_unit]
        [filter]
            {_SUF}
        [/filter]
        variable=temp_MOBILIZE_GUARDIANS_store
    [/store_unit]

    {FOREACH temp_MOBILIZE_GUARDIANS_store temp_MOBILIZE_GUARDIANS_i}
        {CLEAR_VARIABLE "temp_MOBILIZE_GUARDIANS_store[$temp_MOBILIZE_GUARDIANS_i].status.guardian,temp_MOBILIZE_GUARDIANS_store[$temp_MOBILIZE_GUARDIANS_i].ai_special"}
        [unstore_unit]
            variable="temp_MOBILIZE_GUARDIANS_store[$temp_MOBILIZE_GUARDIANS_i]"
            find_vacant=no
        [/unstore_unit]
    {NEXT temp_MOBILIZE_GUARDIANS_i}

    {CLEAR_VARIABLE "temp_MOBILIZE_GUARDIANS_store"}
#enddef

#define NO_EXPERIENCE_UNIT
    # The XP bar won't appear without any advancements.
    # experience=25
    # {AMLA_DEFAULT}
    # advances_to=null
    experience=1000
#enddef

# For use with MOVE_UNIT
#define IGNORE_MOVEMENT_COSTS
    [+move_unit]
        check_passability=no
    [/move_unit]
#enddef

# Resets one or more on-map units to their default statuses (including
# maximum HP, MP, and attacks.
#define RESET_UNIT_STATUSES _SUF
    [store_unit]
        [filter]
            {_SUF}
        [/filter]
        variable=temp_RESET_UNIT_STATUS_store
    [/store_unit]

    {FOREACH temp_RESET_UNIT_STATUS_store temp_RESET_UNIT_STATUS_k}
        # Use a pseudoreference so this doesn't become illegibly long.
        {VARIABLE temp_RESET_UNIT_STATUS_u "temp_RESET_UNIT_STATUS_store[$temp_RESET_UNIT_STATUS_k]"}

        {CLEAR_VARIABLE $temp_RESET_UNIT_STATUS_u|.status.uncovered}
        {CLEAR_VARIABLE $temp_RESET_UNIT_STATUS_u|.status.poisoned}
        {CLEAR_VARIABLE $temp_RESET_UNIT_STATUS_u|.status.slowed}
        {CLEAR_VARIABLE $temp_RESET_UNIT_STATUS_u|.status.petrified}

        [set_variables]
            name=$temp_RESET_UNIT_STATUS_u
            mode=merge
            [value]
                hitpoints=$$temp_RESET_UNIT_STATUS_u|.max_hitpoints
                moves=$$temp_RESET_UNIT_STATUS_u|.max_moves
                attacks_left=$$temp_RESET_UNIT_STATUS_u|.max_attacks
            [/value]
        [/set_variables]

        [unstore_unit]
            variable=$temp_RESET_UNIT_STATUS_u
            find_vacant=no
        [/unstore_unit]
    {NEXT temp_RESET_UNIT_STATUS_k}

    {CLEAR_VARIABLE temp_RESET_UNIT_STATUS_store,temp_RESET_UNIT_STATUS_u}
#enddef

# An alternative to the mainline PUT_TO_RECALL_LIST macro that actually resets
# the affected units' stats before storing in the recall list so they don't
# appear funny the next time they are recalled by the player.

#ifver WESNOTH_VERSION >= 1.13.0

#define RESET_AND_SEND_TO_RECALL_LIST _SUF
    [put_to_recall_list]
        {_SUF}
        heal=yes
    [/put_to_recall_list]
#enddef

#else

#define RESET_AND_SEND_TO_RECALL_LIST _SUF
    [store_unit]
        [filter]
            {_SUF}
        [/filter]
        variable=temp_RESET_AND_SEND_TO_RECALL_LIST_store
        kill=yes
    [/store_unit]

    {FOREACH temp_RESET_AND_SEND_TO_RECALL_LIST_store temp_RESET_AND_SEND_TO_RECALL_LIST_k}
        # Use a pseudoreference so this doesn't become illegibly long.
        {VARIABLE temp_RESET_AND_SEND_TO_RECALL_LIST_var "temp_RESET_AND_SEND_TO_RECALL_LIST_store[$temp_RESET_AND_SEND_TO_RECALL_LIST_k]"}

        {CLEAR_VARIABLE $temp_RESET_AND_SEND_TO_RECALL_LIST_var|.status.uncovered}
        {CLEAR_VARIABLE $temp_RESET_AND_SEND_TO_RECALL_LIST_var|.status.poisoned}
        {CLEAR_VARIABLE $temp_RESET_AND_SEND_TO_RECALL_LIST_var|.status.slowed}
        {CLEAR_VARIABLE $temp_RESET_AND_SEND_TO_RECALL_LIST_var|.status.petrified}

        [set_variables]
            name=$temp_RESET_AND_SEND_TO_RECALL_LIST_var
            mode=merge
            [value]
                hitpoints=$$temp_RESET_AND_SEND_TO_RECALL_LIST_var|.max_hitpoints
                moves=0
                attacks_left=0
            [/value]
        [/set_variables]

        [unstore_unit]
            find_vacant=no
            variable=$temp_RESET_AND_SEND_TO_RECALL_LIST_var
            x,y=recall,recall
        [/unstore_unit]
    {NEXT temp_RESET_AND_SEND_TO_RECALL_LIST_k}

    {CLEAR_VARIABLE temp_RESET_AND_SEND_TO_RECALL_LIST_store,temp_RESET_AND_SEND_TO_RECALL_LIST_var}
#enddef

#endif

#define ATTACH_EVENTS_TO_UNIT _SUF _EVENTS
    [store_unit]
        [filter]
            {_SUF}
        [/filter]
        variable=temp_AETU_store
    [/store_unit]

    [set_variables]
        name=temp_AETU_store_events
        [literal]
            {_EVENTS}
        [/literal]
    [/set_variables]

    [set_variables]
        name=temp_AETU_store.event
        mode=append
        to_variable=temp_AETU_store_events.event
    [/set_variables]

    [unstore_unit]
        variable=temp_AETU_store
        find_vacant=no
    [/unstore_unit]

    {CLEAR_VARIABLE temp_AETU_store,temp_AETU_store_events}
#enddef

#
# Abort an attack sequence by temporarily removing the second unit from the
# map. This is meant to be used in an 'attack' event handler.
#
#define ABORT_ATTACK
    [set_variables]
        name=temp_ABORT_ATTACK_unit
        mode=replace
        to_variable=second_unit
    [/set_variables]

    [kill]
        x,y=$x2,$y2
    [/kill]

    [event]
        name=attack end

        {VARIABLE_INC unit.attacks_left}

        [unstore_unit]
            variable=unit
            find_vacant=no
        [/unstore_unit]

        [unstore_unit]
            variable=temp_ABORT_ATTACK_unit
            find_vacant=no
        [/unstore_unit]

        {CLEAR_VARIABLE temp_ABORT_ATTACK_unit}
    [/event]
#enddef
